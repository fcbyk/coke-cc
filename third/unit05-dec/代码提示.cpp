// 判断一个整数是否是回文数
bool isPalindrome(int n){

    // 方法一：使用字符串的思路
    // 1. 将整数 n 转换成字符串
    // 2. 得到一个与该字符串顺序相反的新字符串
    // 3. 如果原字符串与反转后的字符串相同，说明是回文数
    // 4. 如果不相同，说明不是回文数

    // 方法二：
    // 1. 如果这个数是负数，直接不是回文数
    // 2. 记录原来的数字
    // 3. 不断取这个数的个位，构造一个“反转后的数字”
    // 4. 最后比较反转前和反转后的数是否相等
}

// 使用欧拉筛法求 1 到 n 之间的所有素数
Result eulerSieve(int n){

    // 1. 创建一个大小为 n+1 的布尔数组，用来标记每个数是否为素数
    // 2. 初始时，假设所有数都是素数
    // 3. 明确 0 和 1 不是素数
    // 4. 创建一个整型数组，用来存放已经找到的素数

    // 5. 循环范围 [2,n]，对当前遍历到的数字记为 i
    for () {

        // 如果 i 仍然被标记为素数，将 i 加入素数数组

        // 用已找到的素数筛选
        for () {
            //  计算 i 与 p 的乘积
            //  如果乘积已经超过 n，停止当前筛选
            //  将该乘积对应的位置标记为合数
            //  如果 p 是 i 的最小质因子，停止继续筛选
        }
    }

    // 6. 遍历结束后，同时返回素数标记数组和素数数组
}

// 题目1：线性筛质数
void q1(){
    // 1. 读入两个整数 n 和 q
    //    n 表示筛选素数的上限
    //    q 表示接下来要进行的查询次数

    // 2. 使用筛法，预处理 2 到 n 之间的所有素数
    //    将得到的所有素数按从小到大的顺序存入一个数组

    // 3. 重复进行 q 次查询
    //    对于每一次查询：
    //    3.1 读入一个整数 k
    //    3.2 将 k 转换为从 0 开始计数的下标
    //    3.3 输出素数数组中下标为 k 的那个素数
}

// 输出区间 [a, b] 内的所有回文素数
void q2(){

    // 1. 输入区间的起点 a 和终点 b

    // 2. 预处理 1 到 b 之间的所有素数，得到一个用于判断素数的标记数组

    // 3. 从 a 遍历到 b 的每一个整数，循环范围 [a,b]
    for () {
        // 对当前数字记为 i
        // 如果 i 是素数
        // 并且 i 是回文数
        // 同时满足这两个条件时，输出 i
    }

}

// 统计有多少种方式，可以把 n 表示为连续素数之和
void q3(){

    // 1. 预处理 10000 以内的所有素数
    // 2. 计算一个前缀和数组
    //    前缀和数组的第 i 项表示前 i 个素数的和

    // 3. 不断读入一个整数 n，直到读到 0 为止
    while () {

        // 4. 对于每一个 n
        // 初始化计数器，记录满足条件的方案数

        // 左指针：枚举连续素数的起点位置 [0,连续质数的数量]
        for () {
            // 右指针：枚举连续素数的终点位置 [左指针，连续质数的数量]
            for () {
                //  使用前缀和计算这一段连续素数的和
                //  如果和等于 n，方案数加一
                //  如果和已经大于 n，停止当前尝试
            }
        }


    }

    // 5. 输出方案数
}

// 多次查询区间内素数的个数
void q4(){

    // 1. 预处理 1 到固定上限之间的所有素数

    // 2. 构建一个前缀数组
    //    前缀数组的第 i 项表示 1 到 i 之间的素数个数

    // 3. 不断读入区间 [a, b]
    while () {
        //  如果读入的是 (-1, -1)，结束程序
        //  处理边界,确保a不小于2
        //  错误处理，如果 a 大于 b，输出 0
        //  否则使用前缀数组快速计算区间内素数的个数
        //  区间素数个数 = 前缀[b] - 前缀[a - 1]
    }

}

// 按题目要求输出指定范围内的素数列表
void q5(){

    // 1. 预处理 1 到 1000000 之间的所有素数

    // 2. 不断读入 N 和 C
    while () {

        // 3. 取出所有不大于 N 的素数，存入一个新列表
        //    记录该列表中素数的总个数

        // 4. 根据素数总个数的奇偶性，决定需要输出多少个素数
        //    4.1 如果素数个数是偶数，输出 2C 个
        //    4.2 如果素数个数是奇数，输出 2C - 1 个

        // 5. 如果需要输出的数量大于等于已有素数个数
        //    输出全部素数
        // 6. 否则：
        //    6.1 找到素数列表的中间位置
        //    6.2 从中间向左右对称，截取指定数量的素数
    }

    // 7. 按题目要求格式输出结果
}






